package io.mverse.jsonschema

import io.mverse.jsonschema.keyword.KeywordInfo
import io.mverse.jsonschema.utils.isGeneratedURI
import io.mverse.jsonschema.utils.isJsonPointer
import kotlinx.serialization.Serializable
import kotlinx.serialization.Transient
import lang.hashKode
import lang.json.JsonPath
import lang.net.URI
import lang.net.resolveUri
import lang.serializer.URISerializer

/**
 * Provides location information for any given schema or validation context, including:
 *
 *
 * documentURI: The path to the containing document<br></br>
 * jsonPath: Path within the containing document to the current location<br></br>
 * resolutionScope: The resolution scope for the current location<br></br>
 * canonicalURI: Either an absolute json-pointer from the document base, or a resolution scope (if this location has $id)<br></br>
 * uniqueURI: A potentially autogenerated unique URI that can be used to cache or look up a schema.
 */
@Serializable
class SchemaLocation(
    @Serializable(URISerializer::class)
    val documentURI: URI,

    /**
     * Resolution scope for this location
     */
    @Serializable(URISerializer::class)
    val resolutionScope: URI,

    /**
     * Path within the containing document
     */
    @Serializable(JsonPath.Companion::class)
    val jsonPath: JsonPath,

    /**
     * Private val to support serialization
     */
    @Serializable(URISerializer::class)
    private val _canonicalURI: URI? = null,

    /**
     * Private val to support serialization
     */
    @Serializable(URISerializer::class)
    private val _uniqueURI: URI? = null) {

  /**
   * @return The absolute json-pointer for this location, resolved against the documentURI
   */
  @Transient val absoluteJsonPointerURI: URI by lazy {
    documentURI.resolveUri(jsonPointerFragment)
  }

  @Transient val jsonPointerFragment: URI get() = jsonPath.uriFragment

  /**
   * @return Whether this location has an auto-generated root URI.
   */
  @Transient private val isGenerated: Boolean
    get() = this.documentURI.isGeneratedURI()

  init {
    check(documentURI.isAbsolute()) { "documentURI should be absolute" }
    check(resolutionScope.isAbsolute()) { "resolutionScope should be absolute" }
  }

  /**
   * @see .canonicalURI
   */
  @Transient val canonicalURI: URI by lazy {
    _canonicalURI ?: when (isGenerated) {
      true -> jsonPath.uriFragment
      false -> _uniqueURI ?: this.absoluteJsonPointerURI
    }
  }

  /**
   * @see .uniqueURI
   */
  @Transient val uniqueURI: URI by lazy {
    when {
      _uniqueURI != null -> _uniqueURI
      !isGenerated -> this.canonicalURI
      else -> this.absoluteJsonPointerURI
    }
  }

  fun child(vararg jsonPath: String): SchemaLocation {
    return if (jsonPath.isEmpty()) {
      this
    } else SchemaLocation(documentURI = this.documentURI,
        resolutionScope = resolutionScope,
        jsonPath = this.jsonPath.child(*jsonPath))
  }

  fun child(jsonPath: String): SchemaLocation {
    return SchemaLocation(documentURI = this.documentURI,
        resolutionScope = resolutionScope,
        jsonPath = this.jsonPath.child(jsonPath))
  }

  fun child(key2: Int): SchemaLocation {
    return SchemaLocation(documentURI = this.documentURI,
        resolutionScope = resolutionScope,
        jsonPath = this.jsonPath.child(key2))
  }

  fun child(canonicalId: URI, vararg jsonPath: String): SchemaLocation {
    return toBuilder()
        .id(canonicalId)
        .jsonPath(this.jsonPath.child(*jsonPath))
        .build()
  }

  fun child(keyword: KeywordInfo<*>): SchemaLocation {
    return child(keyword.key)
  }

  fun child(key1: String, key2: Int): SchemaLocation {
    return SchemaLocation(documentURI = this.documentURI,
        resolutionScope = resolutionScope,
        jsonPath = this.jsonPath.child(key1, key2.toString()))
  }

  override fun toString(): String {
    return this.absoluteJsonPointerURI.toString()
  }

  fun withId(id: URI): SchemaLocation {
    return toBuilder()
        .id(id)
        .build()
  }

  private fun toBuilder(): SchemaLocationBuilder {
    return SchemaLocationBuilder(documentURI = documentURI,
        resolutionScope = resolutionScope, jsonPath = jsonPath)
  }

  class SchemaLocationBuilder(internal var documentURI: URI? = null,
                              internal var resolutionScope: URI? = null,
                              internal var id: URI? = null,
                              internal var jsonPath: JsonPath? = null) {

    fun build(block: SchemaLocationBuilder.() -> Unit = {}): SchemaLocation {
      block()
      // Initialize everything from the id
      if (this.documentURI == null && this.id != null) {
        check(id!!.isAbsolute()) { "ID must be absolute" }
        val baseURI = id
        return SchemaLocation(
            _canonicalURI = baseURI,
            documentURI = baseURI!!,
            resolutionScope = baseURI,
            jsonPath = jsonPath ?: ROOT_PATH)
      }

      // Change resolution scope
      if (id != null) {
        check(resolutionScope != null) { "Should have provided a resolution scope" }
        val resolvedURI = resolutionScope!!.resolveUri(id!!)
        return SchemaLocation(_canonicalURI = resolvedURI,
            documentURI = documentURI!!,
            resolutionScope = resolvedURI,
            jsonPath = jsonPath!!)
      }

      // Just changing jsonPath
      return SchemaLocation(documentURI = documentURI!!,
          resolutionScope = resolutionScope ?: documentURI!!,
          jsonPath = jsonPath!!)
    }

    fun id(uri: String): SchemaLocationBuilder {
      return this.id(URI(uri))
    }

    fun id(id: URI): SchemaLocationBuilder {
      this.id = id
      return this
    }

    fun jsonPath(jsonPath: JsonPath): SchemaLocationBuilder {
      this.jsonPath = jsonPath
      return this
    }

    private fun appendJsonPath(vararg pathParts: String): SchemaLocationBuilder {
      return this.jsonPath(this.jsonPath!!.child(*pathParts))
    }
  }

  companion object {
    val ROOT_PATH = JsonPath.rootPath
    val ROOT_URI = URI("#")
    val BLANK_URI = URI("")

    fun documentRoot(id: URI): SchemaLocation {
      val path: JsonPath = if (id.isJsonPointer()) {
        JsonPath.fromURI(id)
      } else {
        ROOT_PATH
      }
      return SchemaLocationBuilder(id).jsonPath(path).build()
    }

    fun documentRoot(id: String): SchemaLocation {
      val rootAsURI = URI(id)
      return documentRoot(rootAsURI)
    }

    fun refLocation(documentURI: URI, id: URI?, refPath: JsonPath): SchemaLocation {
      val resolutionScope: URI
      if (id != null) {
        resolutionScope = documentURI.resolveUri(id)
      } else {
        resolutionScope = documentURI
      }
      return SchemaLocationBuilder(documentURI = documentURI,
          resolutionScope = resolutionScope,
          jsonPath = refPath).build()
    }

    fun builderFromId(id: URI): SchemaLocationBuilder {
      return SchemaLocationBuilder(id = id)
    }
  }

  override fun equals(other: Any?): Boolean {
    return other is SchemaLocation &&
        other.documentURI == this.documentURI &&
        other.jsonPath == this.jsonPath &&
        other.resolutionScope == this.resolutionScope
  }

  override fun hashCode(): Int {
    return hashKode(documentURI, jsonPath, resolutionScope)
  }

  fun withDocumentURI(documentURI: URI): SchemaLocation {
    check(jsonPath == JsonPath.rootPath) { "withDocumentURI cannot be used in the middle of a document" }
    return toBuilder().build {
      val builder = this
      builder.documentURI = documentURI
      builder.id = documentURI
      builder.resolutionScope = documentURI
      builder.jsonPath = ROOT_PATH
    }
  }

  fun withJsonPath(jsonPath: JsonPath):SchemaLocation {
    return toBuilder().build {
      this.jsonPath = jsonPath
    }
  }
}
